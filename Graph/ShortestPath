#include <stdio.h>
#include <string.h>
#define MAXPOINT 32
#define Dtatype int
#define INF 0x3f3f3f3f
int Point;
Dtatype Far[MAXPOINT][MAXPOINT];


//Dijkstra
void Dijkstra(int start) {
	int Marked[Point];
	Datatype lenth[Point];
	memset(Marked,0,sizeof(Marked));
	memset(lenth,0x3f,sizeof(lenth));
	Marked[start] = 1;
	lenth[start] = 0;
	int i,j;
	int v = start;
	for(i=0;i<Point-1;i++) {
		for(j=0;j<Point;j++) {
			if( Far[v][j]+lenth[v] < lenth[j] ) {
				lenth[j] = Far[v][j]+lenth[v];
			}
		}
		int mindex=v;
		Datatype min=INF;
		for(j=0;j<Point;j++) {
			if(Marked[j]==0 && lenth[j]<min) {
				min = lenth[j];
				mindex = j;
			}
		}
		v = mindex;
		Marked[v] = 1;
	}
}


//Floyd
void Floyd() {
	int i,j,k;
	for(k=0;k<Point;k++) {
		for(i=0;i<Point;i++) {
			for(j=0;j<Point;j++) {
				if(Far[i][j]>Far[i][k]+Far[k][j]) {
					Far[i][j] = Far[i][k]+Far[k][j];
				}
			}
		}
	}
}


//SPFA
struct queue {
	int head,tail;
	int capacity = MAXPOINT+1;
	int empty = 1;
	int full = 0;
	int queue[MAXPOINT+1];
};

typedef struct queue Queue;

Queue Q;

void Queue_enque(int dex) {
	Q.queue[Q.tail] = dex;
	if(Q.tail+1 == Q.capacity) {
		Q.tail = 0;
	} else {
		Q.tail++;
	}
	Q.empty = 0;
	if(Q.tail+1 = Q.head) {
		Q.full = 1;
	}
}

int Queue_deque() {
	int n = Q.queue[Q.head];
	if(Q.head+1 == Q.capacity) {
		Q.head = 0;
	} else {
		Q.head++;
	}
	if(Q.head == Q.tail) {
		Q.empty = 1;
	}
	Q.full = 0;
	return n;
}

void SPFA(int start) {
	//初始化
	Datatype lenth[MAXPOINT];
	Q.head = Q.tail = 0;
	memset(Q.queue, -1, sizeof(Q.queue));
	memset(lenth, 0x3f, sizeof(lenth));
	lenth[start] = 0;
	Queue_enque(start);
	//队列操作
	int v;
	while(Q.empty==0) {
		v = Queue_deque();
		for(i=0;i<MAXPOINT;i++) {
			if(Far[v][i]+lenth[v]<lenth[i]) {
				lenth[i] = Far[v][i]+lenth[v];
				Queue_enque(i);
			}
		}
	}
}


